/*
 * Z80 Processor Validation Suite - Pin Definitions
 * 
 * This header defines all pin mappings between the Arduino Mega 2560 and Z80 CPU.
 * Pin assignments are based on hardware/pin_mapping.md.
 * 
 * IMPORTANT: All Z80 control signals are ACTIVE LOW (0 = active, 1 = inactive)
 * 
 * Hardware: Arduino Mega 2560 + Z80 CPU (40-pin DIP)
 * Date: November 5, 2025
 * ✅ Updated: November 7, 2025 - Hardware changes completed
 */

#ifndef PINS_H
#define PINS_H

#include <Arduino.h>

// =============================================================================
// DATA BUS (D0-D7) - Bidirectional - PORTA (Pins 22-29)
// =============================================================================
// All 8 data bits on single port for atomic read/write operations
// These pins must be dynamically configured as INPUT or OUTPUT based on bus cycle
#define Z80_D0    22  // PA0
#define Z80_D1    23  // PA1
#define Z80_D2    24  // PA2
#define Z80_D3    25  // PA3
#define Z80_D4    26  // PA4
#define Z80_D5    27  // PA5
#define Z80_D6    28  // PA6
#define Z80_D7    29  // PA7

// Data bus pin array for efficient access
const uint8_t DATA_BUS_PINS[8] PROGMEM = {
  Z80_D0, Z80_D1, Z80_D2, Z80_D3, 
  Z80_D4, Z80_D5, Z80_D6, Z80_D7
};

// =============================================================================
// ADDRESS BUS (A0-A15) - Inputs to Arduino (Outputs from Z80)
// =============================================================================
// 16-bit address on two complete ports for fast read operations
// Low Byte (A0-A7) - PORTC (Pins 37-30)
// High Byte (A8-A15) - PORTK (Pins A8-A15 / 62-69)

#define Z80_A0    37  // PC0
#define Z80_A1    36  // PC1
#define Z80_A2    35  // PC2
#define Z80_A3    34  // PC3
#define Z80_A4    33  // PC4
#define Z80_A5    32  // PC5
#define Z80_A6    31  // PC6
#define Z80_A7    30  // PC7
#define Z80_A8    62  // PK0 (A8)
#define Z80_A9    63  // PK1 (A9)
#define Z80_A10   64  // PK2 (A10)
#define Z80_A11   65  // PK3 (A11)
#define Z80_A12   66  // PK4 (A12)
#define Z80_A13   67  // PK5 (A13)
#define Z80_A14   68  // PK6 (A14)
#define Z80_A15   69  // PK7 (A15)

// Address bus pin array for efficient access
const uint8_t ADDRESS_BUS_PINS[16] PROGMEM = {
  Z80_A0,  Z80_A1,  Z80_A2,  Z80_A3,
  Z80_A4,  Z80_A5,  Z80_A6,  Z80_A7,
  Z80_A8,  Z80_A9,  Z80_A10, Z80_A11,
  Z80_A12, Z80_A13, Z80_A14, Z80_A15
};

// =============================================================================
// CONTROL SIGNALS - Outputs from Z80 (Inputs to Arduino)
// =============================================================================
// RD on INT5, WR on INT4, other control signals on PORTL
// All control signals are ACTIVE LOW
// ✅ HARDWARE UPDATED: November 14, 2025
#define Z80_MREQ   47  // PL2 - Memory Request (active low)
#define Z80_IORQ   48  // PL1 - I/O Request (active low)
#define Z80_RD     3   // PE5 - Read (active low) - INT5 external interrupt
#define Z80_WR     2   // PE4 - Write (active low) - INT4 external interrupt
#define Z80_M1     45  // PL4 - Machine Cycle 1 (active low)
#define Z80_RFSH   44  // PL5 - Refresh (active low)
#define Z80_HALT   43  // PL6 - Halt Status (active low)
#define Z80_BUSAK  42  // PL7 - Bus Acknowledge (active low)

// Control input pin array for efficient access
const uint8_t CONTROL_INPUT_PINS[8] PROGMEM = {
  Z80_MREQ, Z80_IORQ, Z80_RD, Z80_WR,
  Z80_M1,   Z80_RFSH, Z80_HALT, Z80_BUSAK
};

// =============================================================================
// CONTROL SIGNALS - Inputs to Z80 (Outputs from Arduino) - PORTB
// =============================================================================
// All Arduino output control signals on single port
// All control signals are ACTIVE LOW
#define Z80_RESET  53  // PB0 - Reset (active low)
#define Z80_WAIT   52  // PB1 - Wait State (active low)
#define Z80_INT    51  // PB2 - Interrupt Request (active low)
#define Z80_NMI    50  // PB3 - Non-Maskable Interrupt (active low)
#define Z80_BUSRQ  10  // PB4 - Bus Request (active low)
#define Z80_CLK    11  // PB5 - Clock signal - generated by Timer1 (OC1A)

// Control output pin array for efficient access
const uint8_t CONTROL_OUTPUT_PINS[6] PROGMEM = {
  Z80_RESET, Z80_WAIT, Z80_INT, 
  Z80_NMI,   Z80_BUSRQ, Z80_CLK
};

// =============================================================================
// SIGNAL STATES
// =============================================================================
// Definitions for active-low signal states for code readability
#define SIGNAL_ACTIVE    LOW
#define SIGNAL_INACTIVE  HIGH

// Specific signal states
#define RESET_ACTIVE     LOW
#define RESET_INACTIVE   HIGH

#define MREQ_ACTIVE      LOW
#define MREQ_INACTIVE    HIGH

#define IORQ_ACTIVE      LOW
#define IORQ_INACTIVE    HIGH

#define RD_ACTIVE        LOW
#define RD_INACTIVE      HIGH

#define WR_ACTIVE        LOW
#define WR_INACTIVE      HIGH

#define M1_ACTIVE        LOW
#define M1_INACTIVE      HIGH

#define WAIT_ACTIVE      LOW
#define WAIT_INACTIVE    HIGH

#define INT_ACTIVE       LOW
#define INT_INACTIVE     HIGH

#define NMI_ACTIVE       LOW
#define NMI_INACTIVE     HIGH

#define HALT_ACTIVE      LOW
#define HALT_INACTIVE    HIGH

// =============================================================================
// PIN COUNT CONSTANTS
// =============================================================================
#define DATA_BUS_WIDTH      8
#define ADDRESS_BUS_WIDTH   16
#define CONTROL_INPUT_COUNT 8
#define CONTROL_OUTPUT_COUNT 6

// =============================================================================
// BIT MASKS
// =============================================================================
// Data bus bit masks
#define DATA_BIT_0  0x01  // 0b00000001
#define DATA_BIT_1  0x02  // 0b00000010
#define DATA_BIT_2  0x04  // 0b00000100
#define DATA_BIT_3  0x08  // 0b00001000
#define DATA_BIT_4  0x10  // 0b00010000
#define DATA_BIT_5  0x20  // 0b00100000
#define DATA_BIT_6  0x40  // 0b01000000
#define DATA_BIT_7  0x80  // 0b10000000

// Full bus masks
#define DATA_BUS_MASK     0xFF    // All 8 data bits
#define ADDRESS_BUS_MASK  0xFFFF  // All 16 address bits

// Address range masks
#define ADDRESS_LOW_BYTE   0x00FF  // Lower 8 bits of address (A0-A7)
#define ADDRESS_HIGH_BYTE  0xFF00  // Upper 8 bits of address (A8-A15)

// Common bit manipulation macros
#define BIT_SET(value, bit)     ((value) |= (1 << (bit)))
#define BIT_CLEAR(value, bit)   ((value) &= ~(1 << (bit)))
#define BIT_TOGGLE(value, bit)  ((value) ^= (1 << (bit)))
#define BIT_CHECK(value, bit)   ((value) & (1 << (bit)))
#define BIT_READ(value, bit)    (((value) >> (bit)) & 1)

// Extract high and low bytes
#define HIGH_BYTE(addr)  (((addr) >> 8) & 0xFF)
#define LOW_BYTE(addr)   ((addr) & 0xFF)

// Combine high and low bytes into 16-bit address
#define MAKE_WORD(high, low)  ((((uint16_t)(high)) << 8) | ((uint16_t)(low)))

// =============================================================================
// DIRECT PORT MANIPULATION - Arduino Mega 2560
// =============================================================================
// Arduino Mega 2560 Port Mapping:
// PORTA: D22-D29 (PA0-PA7) - Z80 Data Bus D0-D7
// PORTB: D53, D52, D51, D50, D10-D13 (PB0-PB7) - Z80 Control Outputs + Clock
// PORTC: D37-D30 (PC0-PC7) - Z80 Address Bus A0-A7
// PORTD: D21, D20, D19, D18, D38 (PD0-PD3, PD7) - Available
// PORTE: D0, D1, D2, D3, D5, D4 (PE0-PE5) - Available
// PORTF: A0-A7 (PF0-PF7) - Available (Analog inputs)
// PORTG: D41, D40, D39, D4 (PG0-PG2, PG5) - Available
// PORTH: D6, D7, D8, D9 (PH3-PH6) - Available
// PORTJ: D15, D14 (PJ0-PJ1) - Available
// PORTK: A8-A15 (PK0-PK7) - Z80 Address Bus A8-A15
// PORTL: D48-D42 (PL1-PL7) - Z80 Control Inputs (7 signals)
// PORTE: D0-D5 (PE0-PE5) - Available (PE4=WR on D2/INT4, PE5=RD on D3/INT5)

// Z80 Signal to Port Mapping Summary:
// ✅ HARDWARE UPDATED: November 7, 2025
// PORTA (all 8 bits): Data Bus D0-D7 (pins 22-29) - Bidirectional
// PORTC (all 8 bits): Address Bus A0-A7 (pins 37-30) - Input
// PORTK (all 8 bits): Address Bus A8-A15 (pins A8-A15/62-69) - Input
// PORTL (7 of 8 bits): Control Inputs IORQ,M1,RFSH,HALT,BUSAK (pins 48-42, PL1-PL7) - Input
// PORTE (bits PE4/PE5): RD on PE5 (D3/INT5), WR on PE4 (D2/INT4) - External interrupts
// PORTB (6 of 8 bits): Control Outputs RESET,WAIT,INT,NMI,BUSRQ,CLK (pins 53,52,51,50,10,11) - Output

// Port bit assignments for Z80 signals
// PORTA - Data Bus (All pins D0-D7)
#define PORTA_D0_BIT  0  // D0 = PA0 (pin 22)
#define PORTA_D1_BIT  1  // D1 = PA1 (pin 23)
#define PORTA_D2_BIT  2  // D2 = PA2 (pin 24)
#define PORTA_D3_BIT  3  // D3 = PA3 (pin 25)
#define PORTA_D4_BIT  4  // D4 = PA4 (pin 26)
#define PORTA_D5_BIT  5  // D5 = PA5 (pin 27)
#define PORTA_D6_BIT  6  // D6 = PA6 (pin 28)
#define PORTA_D7_BIT  7  // D7 = PA7 (pin 29)
#define PORTA_DATA_MASK  0xFF  // All 8 bits

// PORTC - Address Bus Low (A0-A7)
#define PORTC_A0_BIT  0  // A0 = PC0 (pin 37)
#define PORTC_A1_BIT  1  // A1 = PC1 (pin 36)
#define PORTC_A2_BIT  2  // A2 = PC2 (pin 35)
#define PORTC_A3_BIT  3  // A3 = PC3 (pin 34)
#define PORTC_A4_BIT  4  // A4 = PC4 (pin 33)
#define PORTC_A5_BIT  5  // A5 = PC5 (pin 32)
#define PORTC_A6_BIT  6  // A6 = PC6 (pin 31)
#define PORTC_A7_BIT  7  // A7 = PC7 (pin 30)
#define PORTC_ADDR_MASK  0xFF  // All 8 bits

// PORTK - Address Bus High (A8-A15)
#define PORTK_A8_BIT   0  // A8  = PK0 (pin A8/62)
#define PORTK_A9_BIT   1  // A9  = PK1 (pin A9/63)
#define PORTK_A10_BIT  2  // A10 = PK2 (pin A10/64)
#define PORTK_A11_BIT  3  // A11 = PK3 (pin A11/65)
#define PORTK_A12_BIT  4  // A12 = PK4 (pin A12/66)
#define PORTK_A13_BIT  5  // A13 = PK5 (pin A13/67)
#define PORTK_A14_BIT  6  // A14 = PK6 (pin A14/68)
#define PORTK_A15_BIT  7  // A15 = PK7 (pin A15/69)
#define PORTK_ADDR_MASK  0xFF  // All 8 bits

// PORTL - Control Inputs from Z80 (7 signals, MREQ moved to PORTE)
// ✅ HARDWARE UPDATED: November 7, 2025
#define PORTL_IORQ_BIT   1  // IORQ  = PL1 (pin 48)
#define PORTL_RD_BIT     2  // RD    = PL2 (pin 47)
#define PORTL_WR_BIT     3  // WR    = PL3 (pin 46)
#define PORTL_M1_BIT     4  // M1    = PL4 (pin 45)
#define PORTL_RFSH_BIT   5  // RFSH  = PL5 (pin 44)
#define PORTL_HALT_BIT   6  // HALT  = PL6 (pin 43)
#define PORTL_BUSAK_BIT  7  // BUSAK = PL7 (pin 42)

#define PORTL_IORQ_MASK   (1 << PORTL_IORQ_BIT)
#define PORTL_RD_MASK     (1 << PORTL_RD_BIT)
#define PORTL_WR_MASK     (1 << PORTL_WR_BIT)
#define PORTL_M1_MASK     (1 << PORTL_M1_BIT)
#define PORTL_RFSH_MASK   (1 << PORTL_RFSH_BIT)
#define PORTL_HALT_MASK   (1 << PORTL_HALT_BIT)
#define PORTL_BUSAK_MASK  (1 << PORTL_BUSAK_BIT)
#define PORTL_CONTROL_MASK  0xFE  // 7 bits (PL1-PL7, not PL0)

// PORTL - MREQ on PL2
#define PORTL_MREQ_BIT   2  // MREQ  = PL2 (pin 47)
#define PORTL_MREQ_MASK  (1 << PORTL_MREQ_BIT)

// PORTE - RD on INT5 external interrupt
#define PORTE_RD_BIT     5  // RD    = PE5 (pin 3, INT5)
#define PORTE_RD_MASK    (1 << PORTE_RD_BIT)

// PORTE - WR on INT4 external interrupt
#define PORTE_WR_BIT     4  // WR    = PE4 (pin D2, INT4)
#define PORTE_WR_MASK    (1 << PORTE_WR_BIT)

// PORTB - Control Outputs to Z80
#define PORTB_RESET_BIT  0  // RESET = PB0 (pin 53)
#define PORTB_WAIT_BIT   1  // WAIT  = PB1 (pin 52)
#define PORTB_INT_BIT    2  // INT   = PB2 (pin 51)
#define PORTB_NMI_BIT    3  // NMI   = PB3 (pin 50)
#define PORTB_BUSRQ_BIT  4  // BUSRQ = PB4 (pin 10)
#define PORTB_CLK_BIT    5  // CLK   = PB5 (pin 11) - Timer1 OC1A

#define PORTB_RESET_MASK  (1 << PORTB_RESET_BIT)
#define PORTB_WAIT_MASK   (1 << PORTB_WAIT_BIT)
#define PORTB_INT_MASK    (1 << PORTB_INT_BIT)
#define PORTB_NMI_MASK    (1 << PORTB_NMI_BIT)
#define PORTB_BUSRQ_MASK  (1 << PORTB_BUSRQ_BIT)
#define PORTB_CLK_MASK    (1 << PORTB_CLK_BIT)
#define PORTB_CONTROL_MASK  0x3F  // Lower 6 bits

// Direct port manipulation macros for fast pin access
#define FAST_PIN_HIGH(port, bit)  ((port) |= (1 << (bit)))
#define FAST_PIN_LOW(port, bit)   ((port) &= ~(1 << (bit)))
#define FAST_PIN_READ(pin, bit)   (((pin) >> (bit)) & 1)
#define FAST_PIN_WRITE(port, bit, value)  do { if (value) FAST_PIN_HIGH(port, bit); else FAST_PIN_LOW(port, bit); } while(0)

// Set port direction (DDR register)
#define FAST_PIN_OUTPUT(ddr, bit)  ((ddr) |= (1 << (bit)))
#define FAST_PIN_INPUT(ddr, bit)   ((ddr) &= ~(1 << (bit)))

#endif // PINS_H
