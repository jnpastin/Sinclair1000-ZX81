# HELLORLD on a Timex Sinclair 1000 or Sinclair ZX81
## What is Hellorld?
David Lovett AKA Usagi Electric on YouTube was restoring a Centurion minicomputer and had an accidental typo during his "Hello World" testing.  This took on a life of its own, as things on the internet often do.  He embraced the chaos and created a "challenge" to have other folks print his same buggy message on a variety of systems.  I got a Timex Sinclair 1000 (the US version of the Sinclair ZX81) not too long ago, and decided that this needed to be done as well
## Timex Sinclair 1000 or Sinclair ZX81 background 
The TS1000/ZX81 is a quirky machine, and that is being generously tactful.  It is a single board Z80 computer with 2K of RAM and a ROM that boots directly into BASIC.  In fact, due to the wonky architecture, BASIC is effectively the only way to interface with the machine.  Programs can be stored on external casette tape and loaded back in, but even that has to run through BASIC.  Saving programs to tape not only copies the program listing but also the entire contents of memory (-ish, more about this later).  The entire machine is in decimal with no real hex capability.  The system doesn't use ASCII character codes for a character map, instead relying on a proprietary map.  Keywords and Functions cannot be entered in letter by letter, the keyboard has different values for each key depending on context.  All keywords and functions are represented this way.  For example a user cannot type **PRINT** as "P", "R", "I", "N", "T", they must use the `P` key when the system is in Keyword context.  Finally, the character set is quite limited, lacking lower-case letters, and most punctuation marks.
## Executing machine code
There is some provision for executing machine code, but it is convoluted at best.  Executing machine code relies on the **USR** Function.  However, Functions cannot be called directly, they must be arguments to a Keyword.  Two common ways of doing this are `PRINT USR xxxxx` and `RAND USR xxxxx`, where `xxxxx` is the memory address of the first instruction.  The **PRINT** method will print the value of the referenced memory address as the return after executing the machine code.  The **RAND** keyword is used to seed the random number generator, so is safe to use, and returns nothing.  The only way to get machine code directly into the machine, without modification of the hardware, is to manually load it into RAM.  There are two common ways of doing this:

1. Place your machine code in a **REM** statement at the beginning of your BASIC program
2. Tell the computer to ignore some amount of space at the top of memory, and store it there.

Option 1 gets pretty weird pretty quickly.  The TS1000/ZX81 doesn't use ASCII codes for its character map, it maintains a proprietary map.  This means that a user can manipulate the contents of RAM by putting (apparently) random characters into their program.  For example: `10 REM YH` is the equivalent of `ld A,$2d`.  Where the `Y` character code is `62d` or `3Eh` and the `H` character code is `45d` or `2Dh`.  This works ok for most situations, but breaks down when entering bytes between `67d` and `110d` (`43h` and `6fh`) and at a handful of other points as they are non-printable characters.  In that situation, the **REM** is typically entered with printable characters in their place, and the correct values can be placed in the correct locations manually via **POKE**.  Fortunately, for Hellorld, there are no non-printable characters, making this fairly easy to accomplish.

Option 2 has its own set of quirks.  When the system powers up, it stores the address of the last byte of RAM in a system variable called RAMTOP.  By overwriting the contents of this variable, some memory can be set aside so that BASIC won't mess with it.  This would seem like a decent solution, except that when saving to tape, the system stops its memory dump at RAMTOP.  This means that the program, while it will persist a **NEW** keyword, will not be saved to tape.  However, it can handle the non-printable characters that the **REM** method cannot.
## My approach
I have followed two different approaches here.  One is a bit simpler, but leverages the system ROM, another is pure machine code.
###Leveraging the system ROM
I have followed both methods here.  Both implementations leverage the same machine code, this can be seen in the assembly program listing.  Printing to the screen in the TS1000/ZX81 is actually quite complicated, so the ROM's **PRINT** subroutine is leveraged (via the `RST $10` instruction).  The **REM** version was fairly straightforward, and is only two lines of BASIC code.  The RAMTOP method is more involved, first the value of RAMTOP must be changed.  Then the machine code can be loaded via **POKE**, then it can be executed.  Either way, the result is a nice "HELLORLD." message, as expected.
###Fullly machine code
In this approach, I only followed the second method.  The REM method was going to result in a large number of manual **POKE** lines to handle the non-printable characters, so only the RAMTOP method is implemented.  As mentioned previously, writing directly to the display is challenging.  The system maintains a memory map where system variables reside beginning at 16384d (4000h), the user's program space then begins at 16509d (407Dh).  The top of RAM is used by a number of system configuration storage areas, including several stacks, program variables, the current line being edited, and the display file.  BASIC moves these around as necessary to conserve RAM for the user's program as much as possible, they are not statically located.

The area that we are interested in is called the D_FILE, this is the area that the system uses to store data displayed on the screen.  There are a few catches to modifying it directly, in fact the documentation from the manufacturer says that modifying the D_FILE or the location of it in the system variables section should not be done and may cause a system crash.  If the system has less than 3.25Kb of RAM, D_FILE is initialized as 25 **NEWLINE** or **ENTER** (ZX81 vs TS1000) characters.  In this situation, every time that a new character needs to be displayed on the screen the D_FILE is expanded to accommodate the extra data.  The system variable that records the beginning memory address is then adjusted.  On systems with more RAM, the D_FILE is fully padded out with spaces filling each line.  This means that the size is static.  

However, in both situations, the file location moves around dynamically a fair bit.  This means that on all systems, the location needs to be discovered at runtime.  Additionally, on low RAM systems, the location of the start needs to be modified to account for the additional data.  In my testing, I found that it was not feasible to anticipate the new location of VARS based on the expansion of D_FILE.  This made moving the contents above D_FILE in memory up impractical.  My approach was to actually move the start of D_FILE down in the address space.  This works because the D_FILE is located directly above the user's program space, so some space can be stolen for the display.  Further, the address stored in the system variables section has to be queried and updated outside of BASIC in order to avoid it changing between execution of one line and the next.  This means that it must all be handled in the machine code generated from the assembly that the program is written in.  Therefore, this implementation has a significant amount of additional logic to cover this process.

Another problem that needs to be addressed is the location of RAMTOP.  The implementation that utilizes the system **PRINT** subroutine is straight spaghetti code, so it can start pretty much anywhere.  However, this implementation has jumps in it.  This means that the assembler needs a proper `.ORG` directive to tell it where things are going to be sitting in memory.  The uploaded code is currently configured for a 2K machine.  I set RAMTOP at 18320d (4790h), and the `.ORG` at 18322d (4792h).  If working on a system with a different amount of RAM, both of these values need to be updated as appropriate.
